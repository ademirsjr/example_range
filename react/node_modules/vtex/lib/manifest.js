"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const fs_extra_1 = require("fs-extra");
const path = require("path");
const ramda_1 = require("ramda");
const errors_1 = require("./errors");
const readFileUtf = (file) => __awaiter(void 0, void 0, void 0, function* () {
    return yield fs_extra_1.readFile(file, 'utf8');
});
const MANIFEST_SCHEMA = 'https://raw.githubusercontent.com/vtex/node-vtex-api/master/gen/manifest.schema';
exports.MANIFEST_FILE_NAME = 'manifest.json';
exports.getAppRoot = () => {
    const cwd = process.cwd();
    const { root: rootDirName } = path.parse(cwd);
    const find = dir => {
        try {
            fs_1.accessSync(path.join(dir, exports.MANIFEST_FILE_NAME));
            return dir;
        }
        catch (e) {
            if (dir === rootDirName) {
                throw new errors_1.CommandError(`Manifest file doesn't exist or is not readable. Please make sure you're in the app's directory or add a manifest.json file in the root folder of the app.`);
            }
            return find(path.resolve(dir, '..'));
        }
    };
    return find(cwd);
};
exports.namePattern = '[\\w_-]+';
exports.vendorPattern = '[\\w_-]+';
exports.versionPattern = '\\d+\\.\\d+\\.\\d+(-.*)?';
exports.wildVersionPattern = '\\d+\\.((\\d+\\.\\d+)|(\\d+\\.x)|x)(-.*)?';
exports.getManifestPath = () => path.resolve(exports.getAppRoot(), exports.MANIFEST_FILE_NAME);
exports.isManifestReadable = () => __awaiter(void 0, void 0, void 0, function* () {
    try {
        yield readFileUtf(exports.getManifestPath());
        return true;
    }
    catch (error) {
        return false;
    }
});
exports.parseManifest = (content) => {
    try {
        return JSON.parse(content);
    }
    catch (e) {
        throw new errors_1.CommandError('Malformed manifest.json file. ' + e);
    }
};
exports.validateAppManifest = (manifest) => {
    const vendorRegex = new RegExp(`^${exports.vendorPattern}$`);
    const nameRegex = new RegExp(`^${exports.namePattern}$`);
    const versionRegex = new RegExp(`^${exports.versionPattern}$`);
    if (manifest.name === undefined) {
        throw new errors_1.CommandError("Field 'name' should be set in manifest.json file");
    }
    if (manifest.version === undefined) {
        throw new errors_1.CommandError("Field 'version' should be set in manifest.json file");
    }
    if (manifest.vendor === undefined) {
        throw new errors_1.CommandError("Field 'vendor' should be set in manifest.json file");
    }
    if (!nameRegex.test(manifest.name)) {
        throw new errors_1.CommandError("Field 'name' may contain only letters, numbers, underscores and hyphens");
    }
    if (!vendorRegex.test(manifest.vendor)) {
        throw new errors_1.CommandError("Field 'vendor' may contain only letters, numbers, underscores and hyphens");
    }
    if (!versionRegex.test(manifest.version)) {
        throw new errors_1.CommandError('The version format is invalid');
    }
};
const appName = new RegExp(`^${exports.vendorPattern}\\.${exports.namePattern}$`);
const appLocator = new RegExp(`^${exports.vendorPattern}\\.${exports.namePattern}(?:@${exports.wildVersionPattern})?$`);
exports.validateApp = (app, skipVersion = false) => {
    const regex = skipVersion ? appName : appLocator;
    if (!regex.test(app)) {
        throw new errors_1.CommandError(`Invalid app format, please use <vendor>.<name>${skipVersion ? '' : '[@<version>]'}`);
    }
    return app;
};
exports.getManifest = ramda_1.memoize(() => __awaiter(void 0, void 0, void 0, function* () {
    const manifest = exports.parseManifest(yield readFileUtf(exports.getManifestPath()));
    exports.validateAppManifest(manifest);
    return manifest;
}));
exports.writeManifestSchema = () => __awaiter(void 0, void 0, void 0, function* () {
    const content = yield readFileUtf(exports.getManifestPath());
    const json = JSON.parse(content);
    if (!json.$schema || json.$schema !== MANIFEST_SCHEMA) {
        json.$schema = MANIFEST_SCHEMA;
        fs_extra_1.writeFile(exports.getManifestPath(), JSON.stringify(json, null, 2));
    }
});
