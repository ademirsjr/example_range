"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const api_1 = require("@vtex/api");
const chalk_1 = require("chalk");
const ora = require("ora");
const ramda_1 = require("ramda");
const locator_1 = require("../../locator");
const logger_1 = require("../../logger");
const utils_1 = require("../../utils");
const prompts_1 = require("../prompts");
const utils_2 = require("../utils");
const utils_3 = require("../utils");
const promptUpdate = () => Promise.resolve(prompts_1.promptConfirm('Apply version updates?'));
const toMajorLocator = (appId) => {
    const [appName, appVersion] = appId.split('@', 2);
    return `${appName}@${locator_1.toMajorRange(appVersion)}`;
};
const sourceFilter = (source) => ramda_1.filter((obj) => includes(ramda_1.prop('source', obj), [source]));
const includes = (k, list) => list.indexOf(k) >= 0;
const printAppsDiff = (resolvedUpdates, message, type, source, onlyShowTableIfVerbose) => {
    let filterFunction;
    let pluckFunction;
    if (type === 'apps') {
        if (!source) {
            throw new Error(`source argument must be supplied when type === 'apps'`);
        }
        filterFunction = sourceFilter(source);
        pluckFunction = ramda_1.pluck('id');
    }
    else if (includes(type, ['infra', 'runtimes'])) {
        filterFunction = ramda_1.identity;
        pluckFunction = ramda_1.identity;
    }
    else {
        throw new Error(`Invalid type: ${type}`);
    }
    const appsToBeUpdated = ramda_1.compose(pluckFunction, filterFunction, ramda_1.path(['updates', type]))(resolvedUpdates);
    const appMajorsToBeUpdated = ramda_1.map(toMajorLocator, appsToBeUpdated);
    const currentApps = ramda_1.compose(ramda_1.filter((appId) => includes(toMajorLocator(appId), appMajorsToBeUpdated)), pluckFunction, ramda_1.path(['state', type]))(resolvedUpdates);
    const diffTable = utils_2.matchedDepsDiffTable('current', 'latest', currentApps, appsToBeUpdated);
    if (diffTable.length === 1) {
        return;
    }
    if (onlyShowTableIfVerbose && !utils_1.isVerbose) {
        console.log(message);
        return;
    }
    console.log(`The following ${message}`);
    console.log(diffTable.toString() + `\n`);
};
const printEditionAppsDiff = (resolvedUpdates) => {
    const oldState = ramda_1.path(['state', 'edition'], resolvedUpdates);
    const newState = ramda_1.difference(ramda_1.union(oldState, ramda_1.path(['updates', 'editionApps', 'install'], resolvedUpdates)), ramda_1.path(['updates', 'editionApps', 'uninstall'], resolvedUpdates));
    const diffTable = utils_2.matchedDepsDiffTable('uninstall', 'install', oldState, newState);
    if (diffTable.length === 1) {
        return;
    }
    console.log(`The following apps will be uninstalled/installed due to changes to current edition:`);
    console.log(diffTable.toString() + '\n');
};
const hasAvailableUpdates = (resolvedUpdates) => {
    const updates = ramda_1.prop('updates', resolvedUpdates);
    const anyAppsUpdates = ramda_1.compose(ramda_1.any(x => !!x), ramda_1.map(x => !ramda_1.isEmpty(x)), ramda_1.props(['apps', 'infra', 'runtimes']))(updates);
    const anyEditionUpdates = ramda_1.compose(ramda_1.any(x => !!x), ramda_1.map(x => !ramda_1.isEmpty(x)), ramda_1.props(['install', 'uninstall']), ramda_1.prop('editionApps'))(updates);
    return anyAppsUpdates || anyEditionUpdates;
};
const printUpdates = (resolvedUpdates) => {
    printAppsDiff(resolvedUpdates, `${chalk_1.default.blue.bold('Infra')} apps will be updated`, 'infra', undefined, true);
    printAppsDiff(resolvedUpdates, `${chalk_1.default.blue.bold('Runtimes')} will be updated`, 'runtimes', undefined, true);
    printAppsDiff(resolvedUpdates, `${chalk_1.default.blue.bold('Installed')} apps will be updated:`, 'apps', 'installation');
    printAppsDiff(resolvedUpdates, `${chalk_1.default.blue.bold('Dependencies')} will be updated:`, 'apps', 'dependency');
    printAppsDiff(resolvedUpdates, `${chalk_1.default.blue.bold('Edition')} apps will be updated`, 'apps', 'edition');
    printEditionAppsDiff(resolvedUpdates);
};
exports.default = () => __awaiter(void 0, void 0, void 0, function* () {
    const housekeeper = new api_1.Housekeeper(utils_3.getIOContext(), utils_3.IOClientOptions);
    const getSpinner = ora('Getting available updates').start();
    const resolvedUpdates = yield housekeeper.resolve();
    getSpinner.stop();
    if (!hasAvailableUpdates(resolvedUpdates)) {
        logger_1.default.info('No updates available');
        return;
    }
    printUpdates(resolvedUpdates);
    const confirm = yield promptUpdate();
    if (!confirm) {
        return;
    }
    const applySpinner = ora('Applying updates').start();
    yield housekeeper.apply(resolvedUpdates);
    applySpinner.stop();
});
