"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Ajv = require("ajv");
const crypto_1 = require("crypto");
const csv = require("csvtojson");
const fs_extra_1 = require("fs-extra");
const jsonSplit = require("json-array-split");
const ProgressBar = require("progress");
const ramda_1 = require("ramda");
const conf_1 = require("../../conf");
const logger_1 = require("../../logger");
exports.LAST_CHANGE_DATE = 'lastChangeDate';
exports.MAX_ENTRIES_PER_REQUEST = 10;
exports.METAINFO_FILE = '.vtex_redirects_metainfo.json';
exports.MAX_RETRIES = 10;
exports.RETRY_INTERVAL_S = 5;
exports.accountAndWorkspace = [conf_1.getAccount(), conf_1.getWorkspace()];
exports.progressString = (message) => `${message} [:bar] :current/:total :percent`;
exports.sleep = milliseconds => new Promise(resolve => setTimeout(resolve, milliseconds));
exports.showGraphQLErrors = (e) => {
    if (e.graphQLErrors) {
        logger_1.default.error(ramda_1.join('\n', ramda_1.pluck('message', e.graphQLErrors)));
        return true;
    }
};
exports.handleReadError = (path) => (error) => {
    console.log(JSON.stringify(error));
    logger_1.default.error(`Error reading file: ${path}`);
    logger_1.default.error(`${error.message}`);
    process.exit();
};
const normalizePath = (path) => ramda_1.compose(ramda_1.replace(/\/+$/, ''), ramda_1.toLower, decodeURI)(path);
const sortFunction = (redirect) => `${crypto_1.createHash('md5')
    .update(normalizePath(ramda_1.prop('from', redirect)))
    .digest('hex')}`;
exports.readCSV = (path) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const result = (yield csv({ delimiter: ';', ignoreEmpty: true }).fromFile(path));
        return ramda_1.sortBy(sortFunction, result);
    }
    catch (e) {
        exports.handleReadError(path)(e);
    }
});
exports.splitJsonArray = (data) => jsonSplit(data, exports.MAX_ENTRIES_PER_REQUEST);
exports.progressBar = (message, curr, total) => new ProgressBar(`${message} [:bar] :current/:total :percent`, {
    complete: '=',
    incomplete: ' ',
    width: '50',
    curr,
    total,
});
const parseErrorDataPath = (dataPath) => {
    return [ramda_1.match(/\[(.*?)\]/, dataPath)[1], ramda_1.match(/\.(.*?)$/, dataPath)[1]];
};
exports.validateInput = (schema, routes) => {
    const validate = new Ajv().compile(schema);
    const isValid = validate(routes);
    if (!isValid) {
        logger_1.default.error('Errors validating input:');
        ramda_1.map(({ message, params, dataPath }) => {
            const [errorObjIndex, errorProp] = parseErrorDataPath(dataPath);
            console.error('-----');
            console.error(`${message} - in ${errorObjIndex} (${errorProp})`);
            console.error(params);
            console.error(`JSON content: \n ${JSON.stringify(routes[ramda_1.keys(routes)[errorObjIndex]], null, 2)}`);
            console.error('-----');
        }, validate.errors);
        process.exit();
    }
};
exports.saveMetainfo = (metainfo, metainfoType, fileHash, counter, data = {}) => {
    if (!metainfo[metainfoType]) {
        metainfo[metainfoType] = {};
    }
    metainfo[metainfoType][fileHash] = { counter, data };
    fs_extra_1.writeJsonSync(exports.METAINFO_FILE, metainfo, { spaces: 2 });
};
exports.deleteMetainfo = (metainfo, metainfoType, fileHash) => {
    if (!metainfo[metainfoType]) {
        return;
    }
    delete metainfo[metainfoType][fileHash];
    fs_extra_1.writeJsonSync(exports.METAINFO_FILE, metainfo, { spaces: 2 });
};
