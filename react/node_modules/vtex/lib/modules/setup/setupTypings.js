"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = require("chalk");
const R = require("ramda");
const clients_1 = require("../../clients");
const conf_1 = require("../../conf");
const env_1 = require("../../env");
const locator_1 = require("../../locator");
const logger_1 = require("../../logger");
const utils_1 = require("../apps/utils");
const utils_2 = require("../utils");
const utils_3 = require("./utils");
const getVendor = (appId) => appId.split('.')[0];
const typingsURLRegex = /_v\/\w*\/typings/;
const appTypingsURL = (appName, appMajorLocator, ignoreLinked) => __awaiter(void 0, void 0, void 0, function* () {
    const appId = ignoreLinked
        ? yield utils_1.appIdFromRegistry(appName, appMajorLocator)
        : yield utils_1.resolveAppId(appName, appMajorLocator);
    const vendor = getVendor(appId);
    const linked = utils_1.isLinked({ version: appId, vendor, name: '', builders: {} });
    const oldSuffix = `/_types/react`;
    const newSuffix = `/@types/${appName}`;
    const base = linked && !ignoreLinked
        ? `https://${conf_1.getWorkspace()}--${conf_1.getAccount()}.${env_1.publicEndpoint()}/_v/private/typings/linked/v1/${appId}/public`
        : `http://vtex.vteximg.com.br/_v/public/typings/v1/${appId}/public`;
    logger_1.default.info(`Checking if ${chalk_1.default.bold(appId)} has new types format`);
    try {
        const newTypesExist = !(yield utils_3.checkIfTarGzIsEmpty(base + newSuffix));
        return base + (newTypesExist ? newSuffix : oldSuffix);
    }
    catch (err) {
        logger_1.default.error(`Error checking if types package is empty for ${base + newSuffix}`);
        throw err;
    }
});
const appsWithTypingsURLs = (appDependencies, ignoreLinked) => __awaiter(void 0, void 0, void 0, function* () {
    const result = {};
    const appNamesAndDependencies = R.toPairs(appDependencies);
    yield Promise.all(appNamesAndDependencies.map(([appName, appVersion]) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            result[appName] = yield appTypingsURL(appName, appVersion, ignoreLinked);
        }
        catch (e) {
            logger_1.default.error(`Unable to generate typings URL for ${appName}@${appVersion}.`);
        }
    })));
    return result;
});
const getBuilderDependencies = (manifestDependencies, typingsData, version, builder) => {
    const builderTypingsData = R.prop(builder, typingsData);
    let injectedDependencies = {};
    if (builderTypingsData && R.has(version, builderTypingsData)) {
        injectedDependencies = R.path([version, 'injectedDependencies'], builderTypingsData);
    }
    return R.merge(manifestDependencies, injectedDependencies);
};
const injectTypingsInPackageJson = (appDeps, ignoreLinked, builder) => __awaiter(void 0, void 0, void 0, function* () {
    let packageJson;
    try {
        packageJson = utils_3.packageJsonEditor.read(builder);
    }
    catch (e) {
        if (e.code === 'ENOENT') {
            logger_1.default.warn(`No package.json found in ${utils_3.packageJsonEditor.path(builder)}.`);
        }
        else
            logger_1.default.error(e);
        return;
    }
    logger_1.default.info(`Injecting typings on ${builder}'s package.json`);
    const oldDevDeps = packageJson.devDependencies || {};
    const oldTypingsEntries = R.filter(R.test(typingsURLRegex), oldDevDeps);
    const newTypingsEntries = yield appsWithTypingsURLs(appDeps, ignoreLinked);
    if (!R.equals(oldTypingsEntries, newTypingsEntries)) {
        const cleanOldDevDeps = R.reject(R.test(typingsURLRegex), oldDevDeps);
        utils_3.packageJsonEditor.write(builder, Object.assign(Object.assign({}, packageJson), { devDependencies: Object.assign(Object.assign({}, cleanOldDevDeps), newTypingsEntries) }));
        try {
            utils_2.runYarn(builder, true);
        }
        catch (e) {
            logger_1.default.error(`Error running Yarn in ${builder}.`);
            utils_3.packageJsonEditor.write(builder, packageJson); // Revert package.json to original state.
        }
    }
});
exports.setupTypings = (manifest, ignoreLinked, buildersToAddTypes) => __awaiter(void 0, void 0, void 0, function* () {
    const appName = manifest.vendor + '.' + manifest.name;
    const appMajor = locator_1.toMajorRange(manifest.version);
    const { builder: builderClient } = clients_1.createClients({}, { retries: 2, timeout: 2000 });
    const builders = R.keys(R.prop('builders', manifest) || {});
    const filteredBuilders = R.intersection(builders, buildersToAddTypes);
    logger_1.default.info('Fetching names of dependencies injected by BuilderHub');
    const typingsData = yield builderClient.typingsInfo();
    const buildersWithAllDeps = filteredBuilders.map((builder) => {
        return {
            builder,
            deps: Object.assign(Object.assign({}, getBuilderDependencies(manifest.dependencies, typingsData, manifest.builders[builder], builder)), (builder === 'node' ? { [appName]: appMajor } : {})),
        };
    });
    yield Promise.all(buildersWithAllDeps.map(({ builder, deps }) => injectTypingsInPackageJson(deps, ignoreLinked, builder)));
});
