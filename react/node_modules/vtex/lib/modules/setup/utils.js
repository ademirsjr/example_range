"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const axios_1 = require("axios");
const fs_extra_1 = require("fs-extra");
const path = require("path");
const stream_1 = require("stream");
const tar = require("tar");
const util = require("util");
const conf_1 = require("../../conf");
const manifest_1 = require("../../manifest");
exports.checkIfTarGzIsEmpty = (url) => {
    return new Promise((resolve, reject) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            const res = yield axios_1.default.get(url, { responseType: 'stream', headers: { Authorization: conf_1.getToken() } });
            let fileCount = 0;
            const fileEmitter = tar.list();
            fileEmitter.on('entry', () => (fileCount += 1));
            yield util.promisify(stream_1.pipeline)([res.data, fileEmitter]);
            resolve(fileCount === 0);
        }
        catch (err) {
            reject(err);
        }
    }));
};
const paths = {
    tsconfig: (builder) => path.join(manifest_1.getAppRoot(), builder, 'tsconfig.json'),
    esLintrc: (builder) => path.join(manifest_1.getAppRoot(), builder, '.eslintrc.json'),
    packageJson: (builder) => path.join(manifest_1.getAppRoot(), builder, 'package.json'),
    eslintIgnore: (builder) => path.join(manifest_1.getAppRoot(), builder, '.eslintignore'),
    prettierrc: (builder) => path.join(manifest_1.getAppRoot(), builder, '.prettierrc'),
};
class FileReaderWriter {
    constructor(file, isJSON = true) {
        this.file = file;
        this.isJSON = isJSON;
        this.path = (builder) => {
            return paths[this.file](builder);
        };
        this.read = (builder) => {
            if (this.isJSON) {
                return fs_extra_1.readJsonSync(this.path(builder));
            }
            return fs_extra_1.readFileSync(this.path(builder));
        };
        this.write = (builder, data) => {
            if (this.isJSON) {
                return fs_extra_1.outputJsonSync(this.path(builder), data, { spaces: 2 });
            }
            return fs_extra_1.outputFileSync(this.path(builder), data);
        };
    }
}
exports.packageJsonEditor = new FileReaderWriter('packageJson');
exports.esLintrcEditor = new FileReaderWriter('esLintrc');
exports.tsconfigEditor = new FileReaderWriter('tsconfig');
exports.eslintIgnoreEditor = new FileReaderWriter('eslintIgnore', false);
exports.prettierrcEditor = new FileReaderWriter('prettierrc');
