"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = require("chalk");
const child_process_es6_promise_1 = require("child-process-es6-promise");
const diff_1 = require("diff");
const fs_extra_1 = require("fs-extra");
const fs_extra_2 = require("fs-extra");
const path_1 = require("path");
const R = require("ramda");
const dummyLogger_1 = require("../clients/dummyLogger");
const conf_1 = require("../conf");
const conf = require("../conf");
const env = require("../env");
const errors_1 = require("../errors");
const logger_1 = require("../logger");
const manifest_1 = require("../manifest");
const sse_1 = require("../sse");
const table_1 = require("../table");
const timeout_1 = require("../timeout");
const user_agent_1 = require("../user-agent");
const prompts_1 = require("./prompts");
const allEvents = ['start', 'success', 'fail', 'timeout', 'logs'];
const flowEvents = ['start', 'success', 'fail'];
exports.yarnPath = `"${require.resolve('yarn/bin/yarn')}"`;
const DEFAULT_TIMEOUT = 10000;
exports.IOClientOptions = {
    timeout: (timeout_1.default || DEFAULT_TIMEOUT),
    retries: 3,
};
exports.getIOContext = () => ({
    account: conf_1.getAccount(),
    authToken: conf_1.getToken(),
    production: false,
    product: '',
    region: env.region(),
    route: {
        id: '',
        params: {},
    },
    userAgent: user_agent_1.default,
    workspace: conf_1.getWorkspace(),
    requestId: '',
    operationId: '',
    logger: dummyLogger_1.dummyLogger,
    platform: '',
});
const onBuildEvent = (ctx, timeout, appOrKey, callback) => {
    const [subject] = appOrKey.split('@');
    const unlistenLogs = sse_1.logAll(ctx, logger_1.default.level, subject);
    const [unlistenStart, unlistenSuccess, unlistenFail] = flowEvents.map(type => sse_1.onEvent(ctx, 'vtex.render-builder', subject, [`build.${type}`], message => callback(type, message)));
    const timer = timeout && setTimeout(() => callback('timeout'), timeout);
    const unlistenMap = {
        fail: unlistenFail,
        logs: unlistenLogs,
        start: unlistenStart,
        success: unlistenSuccess,
        timeout: () => clearTimeout(timer),
    };
    return (...types) => {
        types.forEach(type => {
            unlistenMap[type]();
        });
    };
};
exports.listenBuild = (appOrKey, triggerBuild, options = {}) => {
    return new Promise((resolve, reject) => {
        let triggerResponse;
        const { context = conf_1.currentContext, timeout = 5000 } = options;
        const unlisten = onBuildEvent(context, timeout, appOrKey, (eventType, message) => {
            switch (eventType) {
                case 'start':
                    unlisten('start', 'timeout');
                    break;
                case 'success':
                case 'timeout':
                    unlisten(...allEvents);
                    resolve(triggerResponse);
                    break;
                case 'fail':
                    unlisten(...allEvents);
                    reject(new errors_1.BuildFailError(message));
                    break;
            }
        });
        const unlistenBuild = response => {
            unlisten(...allEvents);
            resolve(response);
        };
        triggerBuild(unlistenBuild)
            .then(response => {
            triggerResponse = response;
        })
            .catch(e => {
            unlisten(...allEvents);
            reject(e);
        });
    });
};
exports.formatNano = (nanoseconds) => `${(nanoseconds / 1e9).toFixed(0)}s ${((nanoseconds / 1e6) % 1e3).toFixed(0)}ms`;
exports.runYarn = (relativePath, force) => {
    logger_1.default.info(`Running yarn in ${chalk_1.default.green(relativePath)}`);
    const root = manifest_1.getAppRoot();
    const command = force
        ? `${exports.yarnPath} --force --non-interactive --ignore-engines`
        : `${exports.yarnPath} --non-interactive --ignore-engines`;
    child_process_es6_promise_1.execSync(command, { stdio: 'inherit', cwd: path_1.resolve(root, relativePath) });
    logger_1.default.info('Finished running yarn');
};
exports.runYarnIfPathExists = (relativePath) => {
    const root = manifest_1.getAppRoot();
    const pathName = path_1.resolve(root, relativePath);
    if (fs_extra_1.existsSync(pathName)) {
        try {
            exports.runYarn(relativePath, false);
        }
        catch (e) {
            logger_1.default.error(`Failed to run yarn in ${chalk_1.default.green(relativePath)}`);
            throw e;
        }
    }
};
const getEntryMapFromObject = (obj, field) => {
    if (Object.prototype.hasOwnProperty.call(obj, field)) {
        return new Map(Object.entries(obj[field]));
    }
    else {
        return new Map();
    }
};
// For each entry in 'left', get all keys that exist but differ in 'right'
const leftMapDifference = (left, right) => {
    return R.filter(x => right.has(x) && left.get(x) !== right.get(x), [...left.keys()]);
};
exports.fixPinnedDependencies = R.curry((pinnedDeps, relativePath) => __awaiter(void 0, void 0, void 0, function* () {
    const jsonPath = path_1.resolve(manifest_1.getAppRoot(), `${relativePath}/package.json`);
    if (!(yield fs_extra_1.pathExists(jsonPath))) {
        return;
    }
    const packageJSON = JSON.parse((yield fs_extra_1.readFile(jsonPath)).toString());
    const dependencies = getEntryMapFromObject(packageJSON, 'dependencies');
    const devDependencies = getEntryMapFromObject(packageJSON, 'devDependencies');
    const outdatedDeps = leftMapDifference(dependencies, pinnedDeps);
    const outdatedDevDeps = leftMapDifference(devDependencies, pinnedDeps);
    const newPackageJSON = R.reduce((obj, dep) => {
        logger_1.default.warn(`${dep} is outdated. Upgrading to ${pinnedDeps.get(dep)}`);
        if (Object.prototype.hasOwnProperty.call(obj, 'dependencies') && obj.dependencies[dep]) {
            obj.dependencies[dep] = pinnedDeps.get(dep);
        }
        if (Object.prototype.hasOwnProperty.call(obj, 'devDependencies') && obj.devDependencies[dep]) {
            obj.devDependencies[dep] = pinnedDeps.get(dep);
        }
        return obj;
    }, packageJSON, [...outdatedDeps, ...outdatedDevDeps]);
    yield fs_extra_2.writeFile(jsonPath, JSON.stringify(newPackageJSON, null, 2) + '\n');
}));
const getSwitchAccountMessage = (previousAccount, currentAccount = conf.getAccount()) => {
    return `Now you are logged in ${chalk_1.default.blue(currentAccount)}. Do you want to return to ${chalk_1.default.blue(previousAccount)} account?`;
};
exports.switchToPreviousAccount = (previousConf) => __awaiter(void 0, void 0, void 0, function* () {
    const previousAccount = previousConf.account;
    if (previousAccount !== conf.getAccount()) {
        const canSwitchToPrevious = yield prompts_1.promptConfirm(getSwitchAccountMessage(previousAccount));
        if (canSwitchToPrevious) {
            conf.saveAll(previousConf);
        }
    }
});
const formatAppId = (appId) => {
    const [appVendor, appName] = R.split('.', appId);
    if (!appName) {
        // Then the app is an 'infra' app.
        const [infraAppVendor, infraAppName] = R.split(':', appId);
        if (!infraAppName) {
            return appId;
        }
        return `${chalk_1.default.blue(infraAppVendor)}:${infraAppName}`;
    }
    return `${chalk_1.default.blue(appVendor)}.${appName}`;
};
const cleanVersion = (appId) => {
    return R.compose((version) => {
        const [pureVersion, build] = R.split('+build', version);
        return build ? `${pureVersion}(linked)` : pureVersion;
    }, R.last, R.split('@'))(appId);
};
exports.matchedDepsDiffTable = (title1, title2, deps1, deps2) => {
    const depsDiff = diff_1.diffArrays(deps1, deps2);
    // Get deduplicated names (no version) of the changed deps.
    const depNames = [
        ...new Set(R.compose(R.map(k => R.head(R.split('@', k))), R.flatten, R.pluck('value'), R.filter((k) => !!k.removed || !!k.added))(depsDiff)),
    ].sort();
    const produceStartValues = () => R.map(_ => [])(depNames);
    // Each of the following objects will start as a { `depName`: [] }, ... }-like.
    const addedDeps = R.zipObj(depNames, produceStartValues());
    const removedDeps = R.zipObj(depNames, produceStartValues());
    // Custom function to set the objects values.
    const setObjectValues = (obj, formatter, filterFunction) => {
        R.compose(R.map(k => {
            const index = R.head(R.split('@', k));
            obj[index].push(formatter(k));
        }), R.flatten, R.pluck('value'), R.filter(filterFunction))(depsDiff);
        R.mapObjIndexed((_, index) => {
            obj[index] = obj[index].join(',');
        })(obj);
    };
    // Setting the objects values.
    setObjectValues(removedDeps, k => chalk_1.default.red(`${cleanVersion(k)}`), (k) => !!k.removed);
    setObjectValues(addedDeps, k => chalk_1.default.green(`${cleanVersion(k)}`), (k) => !!k.added);
    const table = table_1.createTable(); // Set table headers.
    table.push(['', chalk_1.default.bold.yellow(title1), chalk_1.default.bold.yellow(title2)]);
    const formattedDepNames = R.map(formatAppId, depNames);
    // Push array of changed dependencies pairs to the table.
    Array.prototype.push.apply(table, R.map((k) => R.flatten(k))(R.zip(
    // zipping 3 arrays.
    R.zip(formattedDepNames, R.values(removedDeps)), R.values(addedDeps))));
    return table;
};
