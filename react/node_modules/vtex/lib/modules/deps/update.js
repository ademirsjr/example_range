"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = require("chalk");
const diff_1 = require("diff");
const ramda_1 = require("ramda");
const clients_1 = require("../../clients");
const locator_1 = require("../../locator");
const logger_1 = require("../../logger");
const utils_1 = require("../apps/utils");
const utils_2 = require("./utils");
const { getDependencies, updateDependencies, updateDependency } = clients_1.apps;
const cleanDeps = ramda_1.compose(ramda_1.keys, utils_2.removeNpm);
exports.default = (optionalApp, options) => __awaiter(void 0, void 0, void 0, function* () {
    const appsList = ramda_1.prepend(optionalApp, utils_1.parseArgs(options._)).filter(arg => arg && arg !== '');
    try {
        logger_1.default.debug('Starting update process');
        const previousDeps = yield getDependencies();
        let currentDeps;
        if (appsList.length === 0) {
            currentDeps = yield updateDependencies();
        }
        else {
            yield Promise.mapSeries(appsList, (locator) => __awaiter(void 0, void 0, void 0, function* () {
                const { vendor, name, version } = locator_1.parseLocator(locator);
                if (!name || !version) {
                    logger_1.default.error(`App ${locator} has an invalid app format, please use <vendor>.<name>@<version>`);
                }
                else {
                    try {
                        logger_1.default.debug(`Starting to update ${locator}`);
                        yield updateDependency(`${vendor}.${name}`, version, vendor);
                    }
                    catch (e) {
                        logger_1.default.error(e.message);
                        if (ramda_1.path(['response', 'data', 'message'], e)) {
                            logger_1.default.error(e.response.data.message);
                        }
                    }
                }
            }));
            currentDeps = yield getDependencies();
        }
        const [cleanPrevDeps, cleanCurrDeps] = ramda_1.map(cleanDeps, [previousDeps, currentDeps]);
        const diff = diff_1.diffJson(cleanPrevDeps, cleanCurrDeps);
        let nAdded = 0;
        let nRemoved = 0;
        diff.forEach(({ count, value, added, removed }) => {
            const color = added ? chalk_1.default.green : removed ? chalk_1.default.red : chalk_1.default.gray;
            if (added) {
                nAdded += count;
            }
            else if (removed) {
                nRemoved += count;
            }
            process.stdout.write(color(value));
        });
        if (nAdded === 0 && nRemoved === 0) {
            logger_1.default.info('No dependencies updated');
        }
        else {
            if (nAdded > 0) {
                logger_1.default.info('', nAdded, nAdded > 1 ? ' dependencies ' : ' dependency ', chalk_1.default.green('added'), ' successfully');
            }
            if (nRemoved > 0) {
                logger_1.default.info('', nRemoved, nRemoved > 1 ? ' dependencies ' : 'dependency ', chalk_1.default.red('removed'), ' successfully');
            }
        }
    }
    catch (e) {
        logger_1.default.error(e.message);
        if (ramda_1.path(['response', 'data', 'message'], e)) {
            logger_1.default.error(e.response.data.message);
        }
    }
});
