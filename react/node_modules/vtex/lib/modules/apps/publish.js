"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const retry = require("async-retry");
const chalk_1 = require("chalk");
const ora = require("ora");
const ramda_1 = require("ramda");
const clients_1 = require("../../clients");
const conf = require("../../conf");
const env_1 = require("../../env");
const errors_1 = require("../../errors");
const host_1 = require("../../host");
const locator_1 = require("../../locator");
const logger_1 = require("../../logger");
const manifest_1 = require("../../manifest");
const sse_1 = require("../../sse");
const switch_1 = require("../auth/switch");
const build_1 = require("../build");
const prompts_1 = require("../prompts");
const utils_1 = require("../utils");
const utils_2 = require("../utils");
const file_1 = require("./file");
const legacyPublish_1 = require("./legacyPublish");
const utils_3 = require("./utils");
const root = manifest_1.getAppRoot();
const AVAILABILITY_TIMEOUT = 1000;
const N_HOSTS = 5;
const buildersToRunLocalYarn = ['node', 'react'];
const automaticTag = (version) => (version.indexOf('-') > 0 ? null : 'latest');
const publisher = (workspace = 'master') => {
    const publishApp = (appRoot, appId, tag, force, builder) => __awaiter(void 0, void 0, void 0, function* () {
        const paths = yield file_1.listLocalFiles(appRoot);
        const retryOpts = {
            retries: 2,
            minTimeout: 1000,
            factor: 2,
        };
        const publish = (_, tryCount) => __awaiter(void 0, void 0, void 0, function* () {
            const filesWithContent = ramda_1.map(utils_3.pathToFileObject(appRoot), paths);
            if (tryCount === 1) {
                logger_1.default.debug('Sending files:', '\n' + paths.join('\n'));
            }
            if (tryCount > 1) {
                logger_1.default.info(`Retrying...${tryCount - 1}`);
            }
            const stickyHint = yield host_1.getSavedOrMostAvailableHost(appId, builder, N_HOSTS, AVAILABILITY_TIMEOUT);
            const publishOptions = {
                sticky: true,
                stickyHint,
                tag,
            };
            try {
                return yield builder.publishApp(appId, filesWithContent, publishOptions, { skipSemVerEnsure: force });
            }
            catch (err) {
                const response = err.response;
                const status = response.status;
                const data = response && response.data;
                const message = data.message;
                const statusMessage = status ? `: Status ${status}` : '';
                logger_1.default.error(`Error publishing app${statusMessage} (try: ${tryCount})`);
                if (message) {
                    logger_1.default.error(`Message: ${message}`);
                }
                if (status && status < 500) {
                    return;
                }
                throw err;
            }
        });
        return yield retry(publish, retryOpts);
    });
    const publishApps = (path, tag, force) => __awaiter(void 0, void 0, void 0, function* () {
        const previousConf = conf.getAll(); // Store previous configuration in memory
        const manifest = yield manifest_1.getManifest();
        const account = conf.getAccount();
        const builderHubMessage = yield utils_3.checkBuilderHubMessage('publish');
        if (!ramda_1.isEmpty(builderHubMessage)) {
            yield utils_3.showBuilderHubMessage(builderHubMessage.message, builderHubMessage.prompt, manifest);
        }
        if (manifest.vendor !== account) {
            const switchToVendorMsg = `You are trying to publish this app in an account that differs from the indicated vendor. Do you want to publish in account ${chalk_1.default.blue(manifest.vendor)}?`;
            const canSwitchToVendor = yield prompts_1.promptConfirm(switchToVendorMsg);
            if (!canSwitchToVendor) {
                throw new errors_1.UserCancelledError();
            }
            yield switch_1.default(manifest.vendor, {});
        }
        const context = { account: manifest.vendor, workspace, region: env_1.region(), authToken: conf.getToken() };
        const { builder } = clients_1.createClients(context, { timeout: 60000 });
        const pubTag = tag || automaticTag(manifest.version);
        if (manifest.builders.render || manifest.builders['functions-ts']) {
            const unlisten = sse_1.logAll({ account, workspace }, logger_1.default.level, `${manifest.vendor}.${manifest.name}`);
            const { legacyPublishApp } = legacyPublish_1.legacyPublisher(manifest.vendor, workspace);
            yield legacyPublishApp(path, pubTag, manifest).finally(unlisten);
        }
        else {
            const appId = locator_1.toAppLocator(manifest);
            const oraMessage = ora(`Publishing ${appId} ...`);
            const spinner = logger_1.default.level === 'debug' ? oraMessage.info() : oraMessage.start();
            try {
                const senders = ['vtex.builder-hub', 'apps'];
                const { response } = yield build_1.listenBuild(appId, () => publishApp(path, appId, pubTag, force, builder), {
                    waitCompletion: true,
                    context,
                    senders,
                });
                if (response.code !== 'build.accepted') {
                    spinner.warn(`${appId} was published successfully, but you should update your builder hub to the latest version.`);
                }
                else {
                    spinner.succeed(`${appId} was published successfully!`);
                }
            }
            catch (e) {
                spinner.fail(`Failed to publish ${appId}`);
            }
        }
        yield utils_2.switchToPreviousAccount(previousConf);
        Promise.resolve();
    });
    return { publishApp, publishApps };
};
exports.default = (path, options) => {
    logger_1.default.debug(`Starting to publish app in ${conf.getEnvironment()}`);
    path = path || root;
    const workspace = options.w || options.workspace;
    const force = options.f || options.force;
    // Always run yarn locally for some builders
    ramda_1.map(utils_1.runYarnIfPathExists, buildersToRunLocalYarn);
    const { publishApps } = publisher(workspace);
    return publishApps(path, options.tag, force);
};
