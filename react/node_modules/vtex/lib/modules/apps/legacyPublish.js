"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const archiver = require("archiver");
const axios_1 = require("axios");
const ora = require("ora");
const ramda_1 = require("ramda");
const env_1 = require("../../env");
const errors_1 = require("../../errors");
const locator_1 = require("../../locator");
const logger_1 = require("../../logger");
const utils_1 = require("../utils");
const file_1 = require("./file");
const utils_2 = require("./utils");
const routes = {
    Publish: '_v/publish',
};
class LegacyBuilder {
    constructor(opts) {
        this.prePublishApp = (files) => {
            if (!(files[0] && files[0].path && files[0].content)) {
                throw new Error('Argument files must be an array of {path, content}, where content can be a String, a Buffer or a ReadableStream.');
            }
            const indexOfManifest = files.findIndex(({ path }) => path === 'manifest.json');
            if (indexOfManifest === -1) {
                throw new Error('No manifest.json file found in files.');
            }
            const archive = archiver('zip');
            files.forEach(({ content, path }) => archive.append(content, { name: path }));
            archive.finalize();
            return this.http.post(routes.Publish, archive, {
                params: {},
                headers: { 'Content-Type': 'application/octet-stream' },
            });
        };
        const { account, workspace } = opts;
        this.http = axios_1.default.create({
            baseURL: `http://${workspace}--${account}.${env_1.publicEndpoint()}`,
            headers: {
                'User-Agent': 'vtex.toolbelt',
            },
            validateStatus: status => (status >= 200 && status < 300) || status === 304,
        });
    }
}
exports.legacyPublisher = (account, workspace = 'master') => {
    const context = { account, workspace };
    const prePublish = (files, _, unlistenBuild) => __awaiter(void 0, void 0, void 0, function* () {
        const builder = new LegacyBuilder(context);
        const response = yield builder.prePublishApp(files);
        if (response.status === 200) {
            unlistenBuild(response);
            return;
        }
        return response;
    });
    const publishApp = (appRoot, tag, manifest) => __awaiter(void 0, void 0, void 0, function* () {
        const spinner = ora('Publishing legacy app...').start();
        const appId = locator_1.toAppLocator(manifest);
        const options = { context, timeout: null };
        try {
            const paths = yield file_1.listLocalFiles(appRoot);
            const filesWithContent = ramda_1.map(utils_2.pathToFileObject(appRoot), paths);
            logger_1.default.debug('Sending files:', '\n' + paths.join('\n'));
            yield utils_1.listenBuild(appId, unlistenBuild => prePublish(filesWithContent, tag, unlistenBuild), options);
        }
        catch (e) {
            if (e instanceof errors_1.BuildFailError) {
                logger_1.default.error(e.message);
                return;
            }
            if (e.response && e.response.status >= 400 && e.response.status < 500) {
                logger_1.default.error(e.response.data.message);
                return;
            }
            throw e;
        }
        finally {
            spinner.stop();
        }
        logger_1.default.info(`Published app ${appId} successfully at ${account}`);
    });
    return { legacyPublishApp: publishApp };
};
