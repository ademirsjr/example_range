"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const axios_1 = require("axios");
const chalk_1 = require("chalk");
const Table = require("cli-table2");
const enquirer = require("enquirer");
const fs_extra_1 = require("fs-extra");
const path_1 = require("path");
const ramda_1 = require("ramda");
const semverDiff = require("semver-diff");
const clients_1 = require("../../clients");
const conf_1 = require("../../conf");
const errors_1 = require("../../errors");
const logger_1 = require("../../logger");
const manifest_1 = require("../../manifest");
const prompts_1 = require("../prompts");
exports.pathToFileObject = (root = process.cwd(), prefix = '') => (path) => ({
    path: path_1.join(prefix, path),
    content: fs_extra_1.createReadStream(path_1.join(root, path)),
});
const workspaceExampleName = process.env.USER || 'example';
const workspaceMasterAllowedOperations = ['install', 'uninstall'];
// It is not allowed to link apps in a production workspace.
const workspaceProductionAllowedOperatios = ['install', 'uninstall'];
const builderHubMessagesLinkTimeout = 2000; // 2 seconds
const builderHubMessagesPublishTimeout = 10000; // 10 seconds
exports.workspaceMasterMessage = `This action is ${chalk_1.default.red('not allowed')} in workspace ${chalk_1.default.green('master')}, please use another workspace.
You can run "${chalk_1.default.blue(`vtex use ${workspaceExampleName} -r`)}" to use a workspace named "${chalk_1.default.green(workspaceExampleName)}"`;
exports.workspaceProductionMessage = workspace => `This action is ${chalk_1.default.red('not allowed')} in workspace ${chalk_1.default.green(workspace)} because it is a production workspace. You can create a ${chalk_1.default.yellowBright('dev')} workspace called ${chalk_1.default.green(workspaceExampleName)} by running ${chalk_1.default.blue(`vtex use ${workspaceExampleName} -r`)}`;
exports.parseArgs = (args) => {
    return ramda_1.drop(1, args);
};
exports.promptWorkspaceMaster = () => __awaiter(void 0, void 0, void 0, function* () {
    const confirm = yield prompts_1.promptConfirm(`Are you sure you want to force this operation on the ${chalk_1.default.green('master')} workspace?`, false);
    if (!confirm) {
        throw new errors_1.UserCancelledError();
    }
    logger_1.default.warn(`Using ${chalk_1.default.green('master')} workspace. I hope you know what you\'re doing. ðŸ’¥`);
});
exports.validateAppAction = (operation, app) => __awaiter(void 0, void 0, void 0, function* () {
    const account = conf_1.getAccount();
    const workspace = conf_1.getWorkspace();
    if (workspace === 'master') {
        if (!ramda_1.contains(operation, workspaceMasterAllowedOperations)) {
            throw new errors_1.CommandError(exports.workspaceMasterMessage);
        }
        else {
            yield exports.promptWorkspaceMaster();
        }
    }
    const workspaceMeta = yield clients_1.workspaces.get(account, workspace);
    if (workspaceMeta.production && !ramda_1.contains(operation, workspaceProductionAllowedOperatios)) {
        throw new errors_1.CommandError(exports.workspaceProductionMessage(workspace));
    }
    // No app arguments and no manifest file.
    const isReadable = yield manifest_1.isManifestReadable();
    if (!app && !isReadable) {
        throw new errors_1.CommandError(`No app was found, please fix your manifest.json${app ? ' or use <vendor>.<name>[@<version>]' : ''}`);
    }
});
exports.wildVersionByMajor = ramda_1.compose(ramda_1.concat(ramda_1.__, '.x'), ramda_1.head, ramda_1.split('.'));
exports.extractVersionFromId = ramda_1.compose(ramda_1.last, ramda_1.split('@'));
exports.pickLatestVersion = (versions) => {
    const start = ramda_1.head(versions);
    return ramda_1.reduce((acc, version) => {
        return semverDiff(acc, version) ? version : acc;
    }, start, ramda_1.tail(versions));
};
exports.handleError = ramda_1.curry((app, err) => {
    if (err.response && err.response.status === 404) {
        return Promise.reject(new errors_1.CommandError(`App ${chalk_1.default.green(app)} not found`));
    }
    return Promise.reject(err);
});
exports.appLatestMajor = (app) => {
    return exports.appLatestVersion(app).then(exports.wildVersionByMajor);
};
exports.appLatestVersion = (app, version = 'x') => {
    return clients_1.createClients()
        .registry.getAppManifest(app, version)
        .then(ramda_1.prop('id'))
        .then(exports.extractVersionFromId)
        .catch(exports.handleError(app));
};
exports.appIdFromRegistry = (app, majorLocator) => {
    return clients_1.createClients()
        .registry.getAppManifest(app, majorLocator)
        .then(ramda_1.prop('id'))
        .catch(exports.handleError(app));
};
exports.hasServiceOnBuilders = (manifest) => {
    return !!manifest.builders['service-js'];
};
function optionsFormatter(billingOptions) {
    /** TODO: Eliminate the need for this stray, single `cli-table2` dependency */
    const table = new Table({
        head: [{ content: chalk_1.default.cyan.bold('Billing Options'), colSpan: 2, hAlign: 'center' }],
        chars: { 'top-mid': 'â”€', 'bottom-mid': 'â”€', 'mid-mid': 'â”€', middle: ' ' },
    });
    if (billingOptions.free) {
        table.push([{ content: chalk_1.default.green('This app is free'), colSpan: 2, hAlign: 'center' }]);
    }
    else {
        table.push([{ content: 'Plan', hAlign: 'center' }, { content: 'Values', hAlign: 'center' }]);
        billingOptions.policies.forEach(policy => {
            let rowCount = 0;
            const itemsArray = [];
            policy.billing.items.forEach(i => {
                if (i.fixed) {
                    itemsArray.push([{ content: `${i.fixed} ${i.itemCurrency}`, hAlign: 'center', vAlign: 'center' }]);
                    rowCount++;
                }
                else if (i.calculatedByMetricUnit) {
                    if (i.calculatedByMetricUnit.minChargeValue) {
                        itemsArray.push([`Minimum charge: ${i.calculatedByMetricUnit.minChargeValue} ${i.itemCurrency}`]);
                        rowCount++;
                    }
                    let rangesStr = '';
                    i.calculatedByMetricUnit.ranges.forEach(r => {
                        if (r.inclusiveTo) {
                            rangesStr += `${r.multiplier} ${i.itemCurrency}/${i.calculatedByMetricUnit.metricName} (${r.exclusiveFrom} to ${r.inclusiveTo})`;
                            rangesStr += '\nor\n';
                        }
                        else {
                            rangesStr += `${r.multiplier} ${i.itemCurrency}/${i.calculatedByMetricUnit.metricName} (over ${r.exclusiveFrom})`;
                        }
                    });
                    rowCount++;
                    itemsArray.push([{ content: rangesStr, hAlign: 'center', vAlign: 'center' }]);
                }
                itemsArray.push([{ content: '+', hAlign: 'center' }]);
                rowCount++;
            });
            itemsArray.pop();
            rowCount--;
            table.push([
                {
                    content: `${chalk_1.default.yellow(policy.plan)}\n(Charged montlhy)`,
                    rowSpan: rowCount,
                    colSpan: 1,
                    vAlign: 'center',
                    hAlign: 'center',
                },
                itemsArray[0][0],
            ], ...itemsArray.slice(1));
            table.push([
                {
                    content: `The monthly amount will be charged in ${chalk_1.default.red(policy.currency)}`,
                    colSpan: 2,
                    hAlign: 'center',
                },
            ]);
        });
    }
    table.push([
        { content: chalk_1.default.bold('Terms of use:'), hAlign: 'center' },
        { content: billingOptions.termsURL, hAlign: 'center' },
    ]);
    return table.toString();
}
exports.optionsFormatter = optionsFormatter;
function checkBuilderHubMessage(cliRoute) {
    return __awaiter(this, void 0, void 0, function* () {
        const http = axios_1.default.create({
            baseURL: `https://vtex.myvtex.com`,
            timeout: cliRoute === 'link' ? builderHubMessagesLinkTimeout : builderHubMessagesPublishTimeout,
        });
        try {
            const res = yield http.get(`/_v/private/builder/0/getmessage/${cliRoute}`);
            return res.data;
        }
        catch (e) {
            return {};
        }
    });
}
exports.checkBuilderHubMessage = checkBuilderHubMessage;
const promptConfirmName = (msg) => enquirer
    .prompt({
    message: msg,
    name: 'appName',
    type: 'input',
})
    .then(ramda_1.prop('appName'));
function showBuilderHubMessage(message, showPrompt, manifest) {
    return __awaiter(this, void 0, void 0, function* () {
        if (message) {
            if (showPrompt) {
                const confirmMsg = `Are you absolutely sure?\n${message ? message : ''}\nPlease type in the name of the app to confirm (ex: vtex.getting-started):`;
                const appNameInput = yield promptConfirmName(confirmMsg);
                const AppName = `${manifest.vendor}.${manifest.name}`;
                if (appNameInput !== AppName) {
                    throw new errors_1.CommandError(`${appNameInput} doesn't match with the app name.`);
                }
            }
            else {
                logger_1.default.info(message);
            }
        }
    });
}
exports.showBuilderHubMessage = showBuilderHubMessage;
exports.switchAccountMessage = (previousAccount, currentAccount) => {
    return `Now you are logged in ${chalk_1.default.blue(currentAccount)}. Do you want to return to ${chalk_1.default.blue(previousAccount)} account?`;
};
exports.resolveAppId = (appName, appVersion) => __awaiter(void 0, void 0, void 0, function* () { return yield clients_1.apps.getApp(`${appName}@${appVersion}`).then(ramda_1.prop('id')); });
exports.isLinked = ramda_1.propSatisfies(ramda_1.contains('+build'), 'version');
