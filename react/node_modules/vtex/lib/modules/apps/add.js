"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs_extra_1 = require("fs-extra");
const latestVersion = require("latest-version");
const ramda_1 = require("ramda");
const clients_1 = require("../../clients");
const env_1 = require("../../env");
const errors_1 = require("../../errors");
const logger_1 = require("../../logger");
const manifest_1 = require("../../manifest");
const utils_1 = require("./utils");
const unprefixName = ramda_1.compose(ramda_1.last, ramda_1.split(':'));
const invalidAppMessage = 'Invalid app format, please use <vendor>.<name>, <vendor>.<name>@<version>, npm:<name> or npm:<name>@<version>';
const infraLatestVersion = (app) => clients_1.router
    .getAvailableVersions(app)
    .then(ramda_1.path(['versions', env_1.region()]))
    .then(utils_1.pickLatestVersion)
    .then(utils_1.wildVersionByMajor)
    .catch(utils_1.handleError(app));
const npmLatestVersion = (app) => {
    return latestVersion(app)
        .then(ramda_1.concat('^'))
        .catch(err => Promise.reject(new errors_1.CommandError(err.message)));
};
const updateManifestDependencies = (app, version) => {
    return manifest_1.getManifest()
        .then((manifest) => {
        return Object.assign(Object.assign({}, manifest), { dependencies: Object.assign(Object.assign({}, manifest.dependencies), { [app]: version }) });
    })
        .then((newManifest) => JSON.stringify(newManifest, null, 2) + '\n')
        .then((manifestJson) => fs_extra_1.writeFile(manifest_1.getManifestPath(), manifestJson));
};
const addApp = (app) => {
    const hasVersion = app.indexOf('@') > -1;
    if (hasVersion) {
        const [appId, version] = app.split('@');
        return updateManifestDependencies(appId, version);
    }
    const isNpm = app.startsWith('npm:');
    const isInfra = app.startsWith('infra:');
    const appName = app.includes(':') ? unprefixName(app) : app;
    const versionRequest = isNpm
        ? npmLatestVersion(appName)
        : isInfra
            ? infraLatestVersion(appName)
            : utils_1.appLatestMajor(appName);
    return versionRequest.then((version) => updateManifestDependencies(app, version));
};
const addApps = (apps) => {
    const app = ramda_1.head(apps);
    const decApps = ramda_1.tail(apps);
    logger_1.default.debug('Starting to add app', app);
    const appRegex = new RegExp(`^(${manifest_1.vendorPattern}\\.|(npm|infra):)${manifest_1.namePattern}(@${manifest_1.wildVersionPattern})?$`);
    const appPromise = appRegex.test(app) ? addApp(app) : Promise.reject(new errors_1.CommandError(invalidAppMessage));
    return appPromise
        .then(() => (decApps.length > 0 ? addApps(decApps) : Promise.resolve()))
        .catch(err => {
        // A warn message will display the workspaces not deleted.
        if (!err.toolbeltWarning) {
            logger_1.default.warn(`The following app` + (apps.length > 1 ? 's were' : ' was') + ` not added: ${apps.join(', ')}`);
            // the warn message is only displayed the first time the err occurs.
            err.toolbeltWarning = true;
        }
        return Promise.reject(err);
    });
};
exports.default = (app, options) => {
    const apps = ramda_1.prepend(app, utils_1.parseArgs(options._));
    logger_1.default.debug('Adding app' + (apps.length > 1 ? 's' : '') + `: ${apps.join(', ')}`);
    return addApps(apps)
        .then(() => logger_1.default.info('App' + (apps.length > 1 ? 's' : '') + ' added succesfully!'))
        .catch(err => {
        if (err instanceof errors_1.CommandError) {
            logger_1.default.error(err.message);
            return Promise.resolve();
        }
        return Promise.reject(err);
    });
};
