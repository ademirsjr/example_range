"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const axios_1 = require("axios");
const debounce = require("debounce");
const moment = require("moment");
const ramda_1 = require("ramda");
const readline_1 = require("readline");
const chalk_1 = require("chalk");
const apps_1 = require("../../apps");
const clients_1 = require("../../clients");
const conf_1 = require("../../conf");
const conf_2 = require("../../conf");
const env_1 = require("../../env");
const locator_1 = require("../../locator");
const logger_1 = require("../../logger");
const manifest_1 = require("../../manifest");
const sse_1 = require("../../sse");
const debugger_1 = require("./debugger");
const file_1 = require("./file");
const utils_1 = require("./utils");
const { link, patch } = clients_1.apps;
const root = process.cwd();
const pathProp = ramda_1.prop('path');
const mapFilesToChanges = (files) => files.map((path) => ({ path, action: 'save' }));
const sendChanges = (() => {
    let queue = [];
    const publishPatch = debounce((data) => {
        const locator = locator_1.toMajorLocator(data);
        logger_1.default.debug(`Sending ${queue.length} change` + (queue.length > 1 ? 's' : ''));
        return patch(locator, queue)
            .tap(() => console.log(apps_1.changesToString(queue, moment().format('HH:mm:ss'))))
            .tap(() => {
            queue = [];
        });
    }, 50);
    return (changes) => __awaiter(void 0, void 0, void 0, function* () {
        if (changes.length === 0) {
            return;
        }
        queue = ramda_1.uniqBy(pathProp, queue.concat(changes).reverse());
        const manifest = yield manifest_1.getManifest();
        return publishPatch(manifest);
    });
})();
const cleanCache = (manifest) => {
    return clients_1.events.sendEvent('-', 'cleanCache', {
        id: locator_1.toAppLocator(manifest),
        type: 'clean',
    });
};
const checkAppStatus = (manifest) => {
    const { name, vendor, version } = manifest;
    const http = axios_1.default.create({
        baseURL: `http://${name}.${vendor}.${env_1.region()}.vtex.io/${conf_1.getAccount()}/${conf_1.getWorkspace()}`,
        headers: {
            Authorization: conf_1.getToken(),
        },
    });
    return http.get(`/_status?__v=${version}`);
};
const CACHE_CLEAN_AWAIT_MS = 5000;
exports.default = (options) => __awaiter(void 0, void 0, void 0, function* () {
    const manifest = yield manifest_1.getManifest();
    const unlisten = sse_1.logAll(conf_2.currentContext, logger_1.default.level, `${manifest.vendor}.${manifest.name}`);
    if (options.c || options.clean) {
        logger_1.default.info('Requesting to clean cache in builder.');
        cleanCache(manifest);
        yield Promise.delay(CACHE_CLEAN_AWAIT_MS);
    }
    logger_1.default.info('Linking legacy app', `${locator_1.toAppLocator(manifest)}`);
    const majorLocator = locator_1.toMajorLocator(manifest);
    const folder = options.o || options.only;
    const paths = yield file_1.listLocalFiles(root, folder);
    const changes = mapFilesToChanges(paths);
    const batch = file_1.addChangeContent(changes);
    logger_1.default.debug('Sending files:');
    paths.forEach(p => logger_1.default.debug(p));
    logger_1.default.info(`Sending ${batch.length} file` + (batch.length > 1 ? 's' : ''));
    yield link(majorLocator, batch);
    logger_1.default.info(`${batch.length} file` + (batch.length > 1 ? 's' : '') + ' sent');
    const debuggerPort = yield debugger_1.default(manifest);
    if (debuggerPort) {
        logger_1.default.info(`Debugger tunnel listening on ${chalk_1.default.green(`:${debuggerPort}`)}`);
    }
    if (utils_1.hasServiceOnBuilders(manifest)) {
        yield checkAppStatus(manifest);
    }
    yield file_1.watch(root, sendChanges, folder);
    readline_1.createInterface({ input: process.stdin, output: process.stdout }).on('SIGINT', () => {
        unlisten();
        logger_1.default.info('Your app is still in development mode.');
        logger_1.default.info(`You can unlink it with: 'vtex unlink ${majorLocator}'`);
        process.exit();
    });
});
