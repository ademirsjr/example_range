"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const retry = require("async-retry");
const bluebird = require("bluebird");
const chalk_1 = require("chalk");
const chokidar = require("chokidar");
const debounce = require("debounce");
const fs_1 = require("fs");
const moment = require("moment");
const path_1 = require("path");
const ramda_1 = require("ramda");
const readline_1 = require("readline");
const clients_1 = require("../../clients");
const conf_1 = require("../../conf");
const errors_1 = require("../../errors");
const host_1 = require("../../host");
const locator_1 = require("../../locator");
const logger_1 = require("../../logger");
const manifest_1 = require("../../manifest");
const build_1 = require("../build");
const setup_1 = require("../setup");
const utils_1 = require("../utils");
const utils_2 = require("../utils");
const debugger_1 = require("./debugger");
const file_1 = require("./file");
const legacyLink_1 = require("./legacyLink");
const utils_3 = require("./utils");
const root = manifest_1.getAppRoot();
const DELETE_SIGN = chalk_1.default.red('D');
const UPDATE_SIGN = chalk_1.default.blue('U');
const stabilityThreshold = process.platform === 'darwin' ? 100 : 200;
const AVAILABILITY_TIMEOUT = 1000;
const N_HOSTS = 3;
const buildersToStartDebugger = ['node'];
const buildersToRunLocalYarn = ['react', 'node'];
const RETRY_OPTS_INITIAL_LINK = {
    retries: 2,
    minTimeout: 1000,
    factor: 2,
};
const RETRY_OPTS_DEBUGGER = {
    retries: 2,
    minTimeout: 1000,
    factor: 2,
};
const shouldStartDebugger = (manifest) => ramda_1.compose(ramda_1.not, ramda_1.isEmpty, ramda_1.intersection(buildersToStartDebugger), ramda_1.keys, ramda_1.prop('builders'))(manifest);
const warnAndLinkFromStart = (appId, builder, unsafe, extraData = { linkConfig: null }) => {
    logger_1.default.warn('Initial link requested by builder');
    performInitialLink(appId, builder, extraData, unsafe);
    return null;
};
const watchAndSendChanges = (appId, builder, extraData, unsafe) => __awaiter(void 0, void 0, void 0, function* () {
    const changeQueue = [];
    const onInitialLinkRequired = e => {
        const data = e.response && e.response.data;
        if (data && data.code && data.code === 'initial_link_required') {
            return warnAndLinkFromStart(appId, builder, unsafe, extraData);
        }
        throw e;
    };
    const defaultPatterns = ['*/**', 'manifest.json', 'policies.json'];
    const linkedDepsPatterns = ramda_1.map(path => path_1.join(path, '**'), file_1.getLinkedDepsDirs(extraData.linkConfig));
    const queueChange = (path, remove) => {
        console.log(`${chalk_1.default.gray(moment().format('HH:mm:ss:SSS'))} - ${remove ? DELETE_SIGN : UPDATE_SIGN} ${path}`);
        changeQueue.push(pathToChange(path, remove));
        sendChanges();
    };
    const sendChanges = debounce(() => {
        builder
            .relinkApp(appId, changeQueue.splice(0, changeQueue.length), { tsErrorsAsWarnings: unsafe })
            .catch(onInitialLinkRequired);
    }, 1000);
    const pathToChange = (path, remove) => ({
        content: remove ? null : fs_1.readFileSync(path_1.resolve(root, path)).toString('base64'),
        path: pathModifier(path),
    });
    const moduleAndMetadata = ramda_1.toPairs(extraData.linkConfig.metadata);
    const mapLocalToBuiderPath = path => {
        const abs = path_1.resolve(root, path);
        for (const [module, modulePath] of moduleAndMetadata) {
            if (abs.startsWith(modulePath)) {
                return abs.replace(modulePath, path_1.join('.linked_deps', module));
            }
        }
        return path;
    };
    const pathModifier = ramda_1.pipe(mapLocalToBuiderPath, path => path.split(path_1.sep).join('/'));
    const addIgnoreNodeModulesRule = (paths) => paths.concat((path) => path.includes('node_modules'));
    const watcher = chokidar.watch([...defaultPatterns, ...linkedDepsPatterns], {
        atomic: stabilityThreshold,
        awaitWriteFinish: {
            stabilityThreshold,
        },
        cwd: root,
        ignoreInitial: true,
        ignored: addIgnoreNodeModulesRule(file_1.getIgnoredPaths(root)),
        persistent: true,
        usePolling: process.platform === 'win32',
    });
    return new Promise((resolve, reject) => {
        watcher
            .on('add', file => queueChange(file))
            .on('change', file => queueChange(file))
            .on('unlink', file => queueChange(file, true))
            .on('error', reject)
            .on('ready', resolve);
    });
});
const performInitialLink = (appId, builder, extraData, unsafe) => __awaiter(void 0, void 0, void 0, function* () {
    const linkConfig = yield file_1.createLinkConfig(root);
    extraData.linkConfig = linkConfig;
    const usedDeps = ramda_1.toPairs(linkConfig.metadata);
    if (usedDeps.length) {
        const plural = usedDeps.length > 1;
        logger_1.default.info(`The following local dependenc${plural ? 'ies are' : 'y is'} linked to your app:`);
        usedDeps.forEach(([dep, path]) => logger_1.default.info(`${dep} (from: ${path})`));
        logger_1.default.info(`If you don\'t want ${plural ? 'them' : 'it'} to be used by your vtex app, please unlink ${plural ? 'them' : 'it'}`);
    }
    const linkApp = (bail, tryCount) => __awaiter(void 0, void 0, void 0, function* () {
        // wrapper for builder.linkApp to be used with the retry function below.
        const [localFiles, linkedFiles] = yield Promise.all([
            file_1.listLocalFiles(root).then(paths => ramda_1.map(utils_3.pathToFileObject(root), paths)),
            file_1.getLinkedFiles(linkConfig),
        ]);
        const filesWithContent = ramda_1.concat(localFiles, linkedFiles);
        if (tryCount === 1) {
            const linkedFilesInfo = linkedFiles.length ? `(${linkedFiles.length} from linked node modules)` : '';
            logger_1.default.info(`Sending ${filesWithContent.length} file${filesWithContent.length > 1 ? 's' : ''} ${linkedFilesInfo}`);
            logger_1.default.debug('Sending files');
            filesWithContent.forEach(p => logger_1.default.debug(p.path));
        }
        if (tryCount > 1) {
            logger_1.default.info(`Retrying...${tryCount - 1}`);
        }
        const stickyHint = yield host_1.getSavedOrMostAvailableHost(appId, builder, N_HOSTS, AVAILABILITY_TIMEOUT);
        const linkOptions = { sticky: true, stickyHint };
        try {
            const { code } = yield builder.linkApp(appId, filesWithContent, linkOptions, { tsErrorsAsWarnings: unsafe });
            if (code !== 'build.accepted') {
                bail(new Error('Please, update your builder-hub to the latest version!'));
            }
        }
        catch (err) {
            const response = err.response;
            const status = response.status;
            const data = response && response.data;
            const message = data.message;
            const statusMessage = status ? `: Status ${status}` : '';
            logger_1.default.error(`Error linking app${statusMessage} (try: ${tryCount})`);
            if (message) {
                logger_1.default.error(`Message: ${message}`);
            }
            if (status && status < 500) {
                return;
            }
            throw err;
        }
    });
    yield retry(linkApp, RETRY_OPTS_INITIAL_LINK);
});
exports.default = (options) => __awaiter(void 0, void 0, void 0, function* () {
    yield utils_3.validateAppAction('link');
    const unsafe = !!(options.unsafe || options.u);
    const manifest = yield manifest_1.getManifest();
    try {
        yield manifest_1.writeManifestSchema();
    }
    catch (e) {
        logger_1.default.debug('Failed to write schema on manifest.');
    }
    const builderHubMessage = yield utils_3.checkBuilderHubMessage('link');
    if (!ramda_1.isEmpty(builderHubMessage)) {
        yield utils_3.showBuilderHubMessage(builderHubMessage.message, builderHubMessage.prompt, manifest);
    }
    if (manifest.builders.render || manifest.builders['functions-ts']) {
        return legacyLink_1.default(options);
    }
    const appId = locator_1.toAppLocator(manifest);
    const context = { account: conf_1.getAccount(), workspace: conf_1.getWorkspace(), environment: conf_1.getEnvironment() };
    const { builder } = clients_1.createClients(context, { timeout: 60000 });
    if (options.setup || options.s) {
        yield setup_1.default({ 'ignore-linked': false });
    }
    try {
        const aux = yield builder.getPinnedDependencies();
        const pinnedDeps = new Map(Object.entries(aux));
        yield bluebird.map(buildersToRunLocalYarn, utils_1.fixPinnedDependencies(pinnedDeps), { concurrency: 1 });
    }
    catch (e) {
        logger_1.default.info('Failed to check for pinned dependencies');
    }
    // Always run yarn locally for some builders
    ramda_1.map(utils_2.runYarnIfPathExists, buildersToRunLocalYarn);
    if (options.c || options.clean) {
        logger_1.default.info('Requesting to clean cache in builder.');
        const { timeNano } = yield builder.clean(appId);
        logger_1.default.info(`Cache cleaned successfully in ${utils_1.formatNano(timeNano)}`);
    }
    const onError = {
        build_failed: () => {
            logger_1.default.error(`App build failed. Waiting for changes...`);
        },
        initial_link_required: () => warnAndLinkFromStart(appId, builder, unsafe),
    };
    let debuggerStarted = false;
    const onBuild = () => __awaiter(void 0, void 0, void 0, function* () {
        if (debuggerStarted) {
            return;
        }
        const startDebugger = () => __awaiter(void 0, void 0, void 0, function* () {
            const port = yield debugger_1.default(manifest);
            if (!port) {
                throw new Error('Failed to start debugger.');
            }
            return port;
        });
        if (shouldStartDebugger(manifest)) {
            try {
                const debuggerPort = yield retry(startDebugger, RETRY_OPTS_DEBUGGER);
                debuggerStarted = true;
                logger_1.default.info(`Debugger tunnel listening on ${chalk_1.default.green(`:${debuggerPort}`)}. Go to ${chalk_1.default.blue('chrome://inspect')} in Google Chrome to debug your running application.`);
            }
            catch (e) {
                logger_1.default.error(e.message);
            }
        }
    });
    logger_1.default.info(`Linking app ${appId}`);
    let unlistenBuild;
    const extraData = { linkConfig: null };
    try {
        const buildTrigger = performInitialLink.bind(this, appId, builder, extraData, unsafe);
        const [subject] = appId.split('@');
        if (options.watch === false) {
            yield build_1.listenBuild(subject, buildTrigger, { waitCompletion: true });
            return;
        }
        unlistenBuild = yield build_1.listenBuild(subject, buildTrigger, { waitCompletion: false, onBuild, onError }).then(ramda_1.prop('unlisten'));
    }
    catch (e) {
        if (e.response) {
            const { data } = e.response;
            if (data.code === 'routing_error' && /app_not_found.*vtex\.builder\-hub/.test(data.message)) {
                return logger_1.default.error('Please install vtex.builder-hub in your account to enable app linking (vtex install vtex.builder-hub)');
            }
            if (data.code === 'link_on_production') {
                throw new errors_1.CommandError(`Please use a dev workspace to link apps. Create one with (${chalk_1.default.blue('vtex use <workspace> -rp')}) to be able to link apps`);
            }
        }
        throw e;
    }
    readline_1.createInterface({ input: process.stdin, output: process.stdout }).on('SIGINT', () => {
        if (unlistenBuild) {
            unlistenBuild();
        }
        logger_1.default.info('Your app is still in development mode.');
        logger_1.default.info(`You can unlink it with: 'vtex unlink ${appId}'`);
        process.exit();
    });
    yield watchAndSendChanges(appId, builder, extraData, unsafe);
});
