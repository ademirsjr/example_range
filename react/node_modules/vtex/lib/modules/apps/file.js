"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chokidar = require("chokidar");
const fs_extra_1 = require("fs-extra");
const glob = require("globby");
const path_1 = require("path");
const ramda_1 = require("ramda");
const stream_1 = require("stream");
const logger_1 = require("../../logger");
const utils_1 = require("./utils");
const defaultIgnored = [
    '.DS_Store',
    'README.md',
    '.gitignore',
    'package.json',
    'node_modules/**',
    '**/node_modules/**',
    '.git/**',
];
const services = ['react', 'render', 'masterdata', 'service'];
const safeFolder = folder => {
    if (folder && services.indexOf(folder) === -1) {
        logger_1.default.warn('Using unknown service', folder);
    }
    return folder ? './' + folder + '/**' : '*/**';
};
const mapAsync = (f) => (data) => Promise.map(data, f);
function getDirs(root, predicate) {
    const nullInvalidPaths = (path) => fs_extra_1.lstat(path_1.join(root, path))
        .catch(() => null)
        .then(stat => (predicate(path, stat) ? path : null));
    return fs_extra_1.readdir(root)
        .then(mapAsync(nullInvalidPaths))
        .then(dirs => ramda_1.filter(dir => dir != null, dirs));
}
const getLinkedNodeModules = (root) => __awaiter(void 0, void 0, void 0, function* () {
    const isNamespaceOrLink = (path, stat) => stat != null && ((path.startsWith('@') && stat.isDirectory()) || stat.isSymbolicLink());
    const isLink = (_, stat) => stat != null && stat.isSymbolicLink();
    const [namespaces, modules] = (yield getDirs(root, isNamespaceOrLink)
        .catch(() => [])
        .then(ramda_1.partition(dir => dir.startsWith('@'))));
    const getNamespaceLinks = namespace => getDirs(path_1.join(root, namespace), isLink).then(ramda_1.map(dir => [namespace, dir].join('/')));
    const namespaceModules = (yield Promise.map(namespaces, getNamespaceLinks).then(ramda_1.unnest));
    return [...modules, ...namespaceModules];
});
function createLinkConfig(appSrc) {
    return __awaiter(this, void 0, void 0, function* () {
        const stack = [];
        const graph = {};
        const metadata = {};
        const app = yield glob([path_1.join('*', 'package.json')], { cwd: appSrc }).then(ramda_1.map(path_1.dirname));
        function checkLinks(deps) {
            for (const dep of deps) {
                if (dep in graph) {
                    continue;
                }
                stack.push(dep);
                graph[dep] = [];
            }
        }
        function discoverDependencies(module) {
            const path = module in metadata ? metadata[module] : path_1.join(appSrc, module);
            const depsRoot = path_1.join(path, 'node_modules');
            const moduleRealPath = (moduleName) => __awaiter(this, void 0, void 0, function* () {
                return [
                    moduleName,
                    yield fs_extra_1.realpath(path_1.join(depsRoot, ...moduleName.split('/'))),
                ];
            });
            return getLinkedNodeModules(depsRoot)
                .then(mapAsync(moduleRealPath))
                .then(ramda_1.map(addMetadata));
        }
        function addMetadata([moduleName, path]) {
            if (moduleName in metadata && metadata[moduleName] !== path) {
                logger_1.default.warn(`Found ${moduleName} from two sources as linked dependencies. Ignoring the one from ${path}`);
            }
            else {
                metadata[moduleName] = path;
            }
            return moduleName;
        }
        stack.push(...app);
        while (stack.length > 0) {
            const module = stack.pop();
            const dependencies = yield discoverDependencies(module);
            graph[module] = dependencies;
            checkLinks(dependencies);
        }
        return { metadata, graph };
    });
}
exports.createLinkConfig = createLinkConfig;
function getLinkedFiles(linkConfig) {
    return __awaiter(this, void 0, void 0, function* () {
        const ignore = ['.DS_Store', 'README.md', '.gitignore', 'CHANGELOG.md', 'node_modules/**', '**/node_modules/**'];
        const getFiles = ([module, path]) => __awaiter(this, void 0, void 0, function* () {
            return (yield glob(['**'], { cwd: path, ignore, nodir: true }).then(ramda_1.map(utils_1.pathToFileObject(path, path_1.join('.linked_deps', module)))));
        });
        const linkedModulesFiles = ramda_1.unnest(yield Promise.map(ramda_1.toPairs(linkConfig.metadata), getFiles));
        if (linkedModulesFiles.length > 0) {
            linkedModulesFiles.push(jsonToStream(path_1.join('.linked_deps', '.config'), linkConfig));
        }
        return linkedModulesFiles;
    });
}
exports.getLinkedFiles = getLinkedFiles;
function jsonToStream(path, linkConfig) {
    const stream = new stream_1.Readable();
    stream.push(JSON.stringify(linkConfig));
    stream.push(null); // EOF
    return { path, content: stream };
}
function getLinkedDepsDirs(linkConfig) {
    return ramda_1.values(linkConfig.metadata);
}
exports.getLinkedDepsDirs = getLinkedDepsDirs;
const isTestOrMockPath = (p) => /.*(test|mock|snapshot).*/.test(p.toLowerCase());
exports.getIgnoredPaths = (root, test = false) => {
    try {
        const filesToIgnore = fs_extra_1.readFileSync(path_1.join(root, '.vtexignore'))
            .toString()
            .split('\n')
            .map(p => p.trim())
            .filter(p => p !== '')
            .map(p => p.replace(/\/$/, '/**'))
            .concat(defaultIgnored);
        return test ? ramda_1.reject(isTestOrMockPath, filesToIgnore) : filesToIgnore;
    }
    catch (e) {
        return defaultIgnored;
    }
};
exports.listLocalFiles = (root, test = false, folder) => Promise.resolve(glob(['manifest.json', 'policies.json', 'node/.*', 'react/.*', `${safeFolder(folder)}`], {
    cwd: root,
    follow: true,
    ignore: exports.getIgnoredPaths(root, test),
    nodir: true,
}))
    .then((files) => Promise.all(files.map(file => fs_extra_1.lstat(path_1.join(root, file)).then(stats => ({ file, stats })))))
    .then(filesStats => filesStats.reduce((acc, { file, stats }) => {
    if (stats.size > 0) {
        acc.push(file);
    }
    return acc;
}, []));
exports.addChangeContent = (changes) => changes.map(({ path: filePath, action }) => {
    return {
        content: action === 'save' ? fs_extra_1.createReadStream(path_1.resolve(process.cwd(), filePath)) : null,
        path: filePath.split(path_1.sep).join('/'),
    };
});
const sendSaveChanges = (file, sendChanges) => sendChanges(exports.addChangeContent([{ path: file, action: 'save' }]));
const sendRemoveChanges = (file, sendChanges) => sendChanges(exports.addChangeContent([{ path: file, action: 'remove' }]));
exports.watch = (root, sendChanges, folder) => {
    const watcher = chokidar.watch([`${safeFolder(folder)}`, '*.json'], {
        atomic: true,
        awaitWriteFinish: {
            stabilityThreshold: 500,
        },
        cwd: root,
        ignoreInitial: true,
        ignored: exports.getIgnoredPaths(root),
        persistent: true,
        usePolling: true,
    });
    return new Promise((resolve, reject) => {
        watcher
            .on('add', (file, { size }) => (size > 0 ? sendSaveChanges(file, sendChanges) : null))
            .on('change', (file, { size }) => {
            return size > 0 ? sendSaveChanges(file, sendChanges) : sendRemoveChanges(file, sendChanges);
        })
            .on('unlink', file => sendRemoveChanges(file, sendChanges))
            .on('error', reject)
            .on('ready', resolve);
    });
};
