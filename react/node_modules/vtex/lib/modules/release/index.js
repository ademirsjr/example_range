"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = require("chalk");
const ramda_1 = require("ramda");
const semver = require("semver");
const logger_1 = require("../../logger");
const utils_1 = require("./utils");
const releaseTypeAliases = {
    pre: 'prerelease',
};
const supportedReleaseTypes = ['major', 'minor', 'patch', 'prerelease'];
const supportedTagNames = ['stable', 'beta', 'hkignore'];
const releaseTypesToUpdateChangelog = ['major', 'minor', 'patch'];
const tagNamesToUpdateChangelog = ['stable'];
const shouldUpdateChangelog = (releaseType, tagName) => {
    return ((releaseTypesToUpdateChangelog.indexOf(releaseType) >= 0 && tagNamesToUpdateChangelog.indexOf(tagName) >= 0) ||
        semver.valid(releaseType));
};
const getNewAndOldVersions = (releaseType, tagName) => {
    if (semver.valid(releaseType)) {
        // If `releaseType` is a valid (semver) version, use it.
        const oldVersion = utils_1.readVersion();
        const newVersion = semver.parse(releaseType).version;
        if (!semver.gt(newVersion, oldVersion)) {
            // TODO: Remove the below log.error when toolbelt has better error handling.
            logger_1.default.error(`The new version has to be greater than the old one: \
${newVersion} <= ${oldVersion}`);
            throw new Error(`The new version has to be greater than the old one: \
${newVersion} <= ${oldVersion}`);
        }
        return [oldVersion, newVersion];
    }
    else {
        // Else `releaseType` is just a regular release type. Then we increment the
        // actual version.
        // Check if releaseType is valid.
        if (ramda_1.indexOf(releaseType, supportedReleaseTypes) === -1) {
            // TODO: Remove the below log.error when toolbelt has better error handling.
            logger_1.default.error(`Invalid release type: ${releaseType}
Valid release types are: ${supportedReleaseTypes.join(', ')}`);
            throw new Error(`Invalid release type: ${releaseType}
Valid release types are: ${supportedReleaseTypes.join(', ')}`);
        }
        // Check if tagName is valid.
        if (ramda_1.indexOf(tagName, supportedTagNames) === -1) {
            // TODO: Remove the below log.error when toolbelt has better error handling.
            logger_1.default.error(`Invalid release tag: ${tagName}
Valid release tags are: ${supportedTagNames.join(', ')}`);
            throw new Error(`Invalid release tag: ${tagName}
Valid release tags are: ${supportedTagNames.join(', ')}`);
        }
        const oldVersion = utils_1.readVersion();
        const newVersion = utils_1.incrementVersion(oldVersion, releaseType, tagName);
        return [oldVersion, newVersion];
    }
};
exports.default = (releaseType = 'patch', // This arg. can also be a valid (semver) version.
tagName = 'beta') => __awaiter(void 0, void 0, void 0, function* () {
    utils_1.checkGit();
    utils_1.checkIfInGitRepo();
    const normalizedReleaseType = ramda_1.prop(releaseType, releaseTypeAliases) || releaseType;
    const [oldVersion, newVersion] = getNewAndOldVersions(normalizedReleaseType, tagName);
    logger_1.default.info(`Old version: ${chalk_1.default.bold(oldVersion)}`);
    logger_1.default.info(`New version: ${chalk_1.default.bold.yellow(newVersion)}`);
    const [month, day, year] = new Date()
        .toLocaleDateString('en-US', { year: 'numeric', month: '2-digit', day: '2-digit' })
        .split('/');
    // Pachamama v2 requires that version tags start with a 'v' character.
    const tagText = `v${newVersion}`;
    const changelogVersion = `\n\n## [${newVersion}] - ${year}-${month}-${day}`;
    if (!(yield utils_1.confirmRelease())) {
        // Abort release.
        return;
    }
    logger_1.default.info('Starting release...');
    try {
        yield utils_1.preRelease();
        yield utils_1.bump(newVersion);
        if (shouldUpdateChangelog(normalizedReleaseType, tagName)) {
            utils_1.updateChangelog(changelogVersion);
        }
        yield utils_1.add();
        yield utils_1.commit(tagText);
        yield utils_1.tag(tagText);
        yield utils_1.push(tagText);
        yield utils_1.postRelease();
    }
    catch (e) {
        logger_1.default.error(`Failed to release \n${e}`);
    }
});
