"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = require("chalk");
const enquirer = require("enquirer");
const ramda_1 = require("ramda");
const semver = require("semver");
const errors_1 = require("../../../errors");
const logger_1 = require("../../../logger");
const prompts_1 = require("../../prompts");
const utils_1 = require("./utils");
const promptSignificanceLevel = () => __awaiter(void 0, void 0, void 0, function* () {
    const significanceTimePreviews = yield Promise.all(ramda_1.compose(ramda_1.map(value => utils_1.abtester.preview(value)), ramda_1.values)(utils_1.SIGNIFICANCE_LEVELS));
    const significanceTimePreviewMap = ramda_1.fromPairs(ramda_1.zip(ramda_1.keys(utils_1.SIGNIFICANCE_LEVELS), significanceTimePreviews));
    return yield enquirer
        .prompt({
        name: 'level',
        message: 'Choose the significance level:',
        type: 'select',
        choices: ramda_1.values(ramda_1.mapObjIndexed((value, key) => ({
            message: `${key} (~ ${utils_1.formatDays(value)})`,
            value: key,
        }))(significanceTimePreviewMap)),
    })
        .then(ramda_1.prop('level'));
});
const promptContinue = (workspace, significanceLevel) => __awaiter(void 0, void 0, void 0, function* () {
    const proceed = significanceLevel
        ? yield prompts_1.promptConfirm(`You are about to start an A/B test between workspaces \
${chalk_1.default.green('master')} and ${chalk_1.default.green(workspace)} with \
${chalk_1.default.red(significanceLevel)} significance level. Proceed?`, false)
        : yield prompts_1.promptConfirm(`You are about to start an A/B test between workspaces \
${chalk_1.default.green('master')} and ${chalk_1.default.green(workspace)}. Proceed?`, false);
    if (!proceed) {
        throw new errors_1.UserCancelledError();
    }
});
exports.default = () => __awaiter(void 0, void 0, void 0, function* () {
    const abTesterManifest = yield utils_1.installedABTester();
    const workspace = yield utils_1.promptProductionWorkspace('Choose production workspace to start A/B test:');
    try {
        if (semver.satisfies(abTesterManifest.version, '>=0.10.0')) {
            logger_1.default.info(`Setting workspace ${chalk_1.default.green(workspace)} to A/B test`);
            yield promptContinue(workspace);
            const proportion = Number(yield utils_1.promptProportionTrafic());
            const timeLength = Number(yield utils_1.promptConstraintDuration());
            yield utils_1.abtester.customStart(workspace, timeLength, proportion);
            logger_1.default.info(`Workspace ${chalk_1.default.green(String(workspace))} in A/B test`);
            logger_1.default.info(`You can stop the test using ${chalk_1.default.blue('vtex workspace abtest finish')}`);
            return;
        }
        const significanceLevel = yield promptSignificanceLevel();
        yield promptContinue(workspace, significanceLevel);
        const significanceLevelValue = utils_1.SIGNIFICANCE_LEVELS[significanceLevel];
        logger_1.default.info(`Setting workspace ${chalk_1.default.green(workspace)} to A/B test with \
        ${significanceLevel} significance level`);
        yield utils_1.abtester.startLegacy(workspace, significanceLevelValue);
        logger_1.default.info(`Workspace ${chalk_1.default.green(workspace)} in A/B test`);
        logger_1.default.info(`You can stop the test using ${chalk_1.default.blue('vtex workspace abtest finish')}`);
    }
    catch (err) {
        if (err.message === 'Workspace not found') {
            console.log(`Test not initialized due to workspace ${workspace} not found by ab-tester.`);
        }
    }
});
