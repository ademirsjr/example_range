#!/usr/bin/env node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
require("any-promise/register/bluebird");
const axios_1 = require("axios");
const Bluebird = require("bluebird");
const chalk_1 = require("chalk");
const clear_module_1 = require("clear-module");
const findhelp_1 = require("findhelp");
const os = require("os");
const path = require("path");
const ramda_1 = require("ramda");
const ramda_adjunct_1 = require("ramda-adjunct");
const semver = require("semver");
const pkg = require("../package.json");
const conf = require("./conf");
const conf_1 = require("./conf");
const env_1 = require("./env");
const errors_1 = require("./errors");
const logger_1 = require("./logger");
const tree_1 = require("./modules/tree");
const Token_js_1 = require("./Token.js");
const update_1 = require("./update");
const utils_1 = require("./utils");
const nodeVersion = process.version.replace('v', '');
if (!semver.satisfies(nodeVersion, pkg.engines.node)) {
    const minMajor = pkg.engines.node.replace('>=', '');
    console.error(chalk_1.default.bold(`Incompatible with node < v${minMajor}. Please upgrade node to major ${minMajor} or higher.`));
    process.exit(1);
}
axios_1.default.interceptors.request.use(config => {
    if (env_1.envCookies()) {
        config.headers.Cookie = `${env_1.envCookies()}; ${config.headers.Cookie || ''}`;
    }
    return config;
});
global.Promise = Bluebird;
Bluebird.config({
    cancellation: true,
});
const run = command => Bluebird.resolve(findhelp_1.run.call(tree_1.default, command, path.join(__dirname, 'modules')));
const loginCmd = tree_1.default.login;
let loginPending = false;
if (process.env.NODE_ENV === 'development') {
    try {
        require('longjohn'); // tslint:disable-line
    }
    catch (e) {
        logger_1.default.debug("Couldn't require longjohn. If you want long stack traces, run: npm install -g longjohn");
    }
}
// Show update notification if newer version is available
update_1.default();
const logToolbeltVersion = () => {
    logger_1.default.debug(`Toolbelt version: ${pkg.version}`);
};
const checkLogin = args => {
    const first = args[0];
    const whitelist = [undefined, 'config', 'login', 'logout', 'switch', 'whoami', 'init', '-v', '--version', 'release'];
    const token = new Token_js_1.Token(conf_1.getToken());
    if (!token.isValid() && whitelist.indexOf(first) === -1) {
        logger_1.default.debug('Requesting login before command:', args.join(' '));
        return run({ command: loginCmd });
    }
};
const main = () => __awaiter(void 0, void 0, void 0, function* () {
    const args = process.argv.slice(2);
    conf.saveEnvironment(conf.Environment.Production); // Just to be backwards compatible with who used staging previously
    logToolbeltVersion();
    logger_1.default.debug('node %s - %s %s', process.version, os.platform(), os.release());
    logger_1.default.debug(args);
    yield checkLogin(args);
    const command = yield findhelp_1.find(tree_1.default, ramda_1.without([utils_1.VERBOSE], args));
    if (utils_1.isVerbose) {
        const findWhoami = yield findhelp_1.find(tree_1.default, ['whoami']);
        if (command.command !== findWhoami.command) {
            yield run(findWhoami);
        }
    }
    yield run(command);
});
const onError = e => {
    const status = e.response && e.response.status;
    const statusText = e.response && e.response.statusText;
    const data = e.response && e.response.data;
    const code = e.code || null;
    if (status) {
        if (status === 401) {
            if (!loginPending) {
                logger_1.default.error('There was an authentication error. Please login again');
                // Try to login and re-issue the command.
                loginPending = true;
                return run({ command: loginCmd })
                    .tap(clear_module_1.all)
                    .then(main); // TODO: catch with different handler for second error
            }
            else {
                return; // Prevent multiple login attempts
            }
        }
        if (status >= 400) {
            const message = data ? data.message : null;
            const source = e.config.url;
            logger_1.default.error('API:', status, statusText);
            if (message) {
                logger_1.default.error('Message:', message);
                if (utils_1.isVerbose) {
                    logger_1.default.debug('Raw error:', data);
                }
            }
            else {
                logger_1.default.error('Raw error:', {
                    data,
                    source,
                });
            }
        }
        else {
            logger_1.default.error('Oops! There was an unexpected error:');
            logger_1.default.error(e.read ? e.read().toString('utf8') : data);
        }
    }
    else if (code) {
        switch (code) {
            case 'ENOTFOUND':
                logger_1.default.error('Connection failure :(');
                logger_1.default.error('Please check your internet');
                break;
            case 'EAI_AGAIN':
                logger_1.default.error('A temporary failure in name resolution occurred :(');
                break;
            default:
                logger_1.default.error('Unhandled exception');
                logger_1.default.error('Please report the issue in https://github.com/vtex/toolbelt/issues');
                if (e.config && e.config.url && e.config.method) {
                    logger_1.default.error(`${e.config.method} ${e.config.url}`);
                }
                if (utils_1.isVerbose) {
                    console.log(e);
                }
        }
    }
    else {
        switch (e.name) {
            case findhelp_1.MissingRequiredArgsError.name:
                logger_1.default.error('Missing required arguments:', chalk_1.default.blue(e.message));
                break;
            case findhelp_1.CommandNotFoundError.name:
                logger_1.default.error('Command not found:', chalk_1.default.blue(...process.argv.slice(2)));
                break;
            case errors_1.CommandError.name:
                if (e.message && e.message !== '') {
                    logger_1.default.error(e.message);
                }
                break;
            case errors_1.SSEConnectionError.name:
                logger_1.default.error('Connection to login server has failed');
                break;
            case errors_1.UserCancelledError.name:
                logger_1.default.debug('User Cancelled');
                break;
            default:
                logger_1.default.error('Unhandled exception');
                logger_1.default.error('Please report the issue in https://github.com/vtex/toolbelt/issues');
                logger_1.default.error(ramda_1.reject(ramda_adjunct_1.isFunction, e));
                if (utils_1.isVerbose) {
                    console.log(e);
                }
        }
    }
    process.exit(1);
};
try {
    main().catch(onError);
}
catch (e) {
    onError(e);
}
process.on('unhandledRejection', onError);
